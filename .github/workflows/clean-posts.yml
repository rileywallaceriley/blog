name: Clean Posts

on:
  workflow_dispatch:
    inputs:
      source_name:
        description: 'Source name (e.g. HipHopDX, AAHIPHOP, Exclaim, XXL)'
        required: true
        default: 'HipHopDX'
      input_file:
        description: 'Input JSON filename in repo root'
        required: true
        default: 'posts_complete.json'
      output_file:
        description: 'Output JSON filename'
        required: true
        default: 'posts_cleaned.json'

jobs:
  clean:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Write script
        run: |
          cat > cleaner.mjs << 'EOF'
          import fs from 'fs';
          import https from 'https';

          const API_KEY     = process.env.ANTHROPIC_API_KEY || '';
          const SOURCE_NAME = process.env.SOURCE_NAME || '';
          const INPUT       = process.env.INPUT_FILE || 'posts_complete.json';
          const OUTPUT      = process.env.OUTPUT_FILE || 'posts_cleaned.json';
          const PROGRESS    = 'clean_progress.json';
          const DELAY       = 600;

          const sleep = ms => new Promise(r => setTimeout(r, ms));

          // ── REGEX PRE-CLEAN ──────────────────────────────────────────
          // Fixes systematic CMS encoding artifacts before AI sees the text
          function regexClean(text) {
            if (!text) return '';
            let t = text;

            // Strip HTML tags and broken URLs
            t = t.replace(/<https?:\/\/[^>]+>/g, '');
            t = t.replace(/<[^>]+>/g, '');

            // Fix spaces INSIDE opening quotes: " word → "word  OR  " word → "word
            t = t.replace(/\"\s+/g, '"');
            t = t.replace(/"\s+([a-zA-Z0-9])/g, (m, p1) => '"' + p1);

            // Fix spaces INSIDE closing quotes: word " → word"  OR  word " → word"
            t = t.replace(/\s+\"/g, '"');
            t = t.replace(/([a-zA-Z0-9,.])\s+"/g, (m, p1) => p1 + '"');

            // Fix missing space BEFORE opening quote: word" → word "  (but not after punctuation)
            t = t.replace(/([a-zA-Z0-9])"([a-zA-Z])/g, '$1 "$2');

            // Fix missing space AFTER closing quote: "word"next → "word" next
            t = t.replace(/"([a-zA-Z0-9].*?)"([a-zA-Z])/g, '"$1" $2');

            // Fix backslash-escaped quotes first: \" → "
            t = t.replace(/\\"/g, '"');

            // Fix mismatched quotes — all variations:
            // "word'  →  "word"
            t = t.replace(/"([^"\n]{1,80})'/g, '"$1"');
            // 'word"  →  "word"
            t = t.replace(/'([^"\n]{1,80})"/g, '"$1"');
            // "word\'  (escaped single) → "word"
            t = t.replace(/"([^"\n]{1,80})\\'/g, '"$1"');
            // Standalone mismatched close: word' at end of sentence where context is a quote
            t = t.replace(/(\w)'(\s*[,\.!\?\s])/g, '$1"$2');

            // Fix run-on sentences missing space after period before capital
            t = t.replace(/\.([A-Z])/g, '. $1');

            // Fix missing space after comma before letter
            t = t.replace(/,([a-zA-Z])/g, ', $1');

            // Normalize multiple spaces
            t = t.replace(/  +/g, ' ');

            // Clean up paragraph spacing
            t = t.replace(/\n{3,}/g, '\n\n');

            return t.trim();
          }

          function toHTML(text) {
            if (!text) return '';
            return text.split(/\n\n+/).map(p => '<p>' + p.trim() + '</p>').filter(p => p !== '<p></p>').join('');
          }

          function api(system, user) {
            return new Promise((resolve, reject) => {
              const body = JSON.stringify({ model: 'claude-haiku-4-5-20251001', max_tokens: 4096, system, messages: [{ role: 'user', content: user }] });
              const req = https.request({
                hostname: 'api.anthropic.com', path: '/v1/messages', method: 'POST',
                headers: { 'Content-Type': 'application/json', 'x-api-key': API_KEY, 'anthropic-version': '2023-06-01', 'Content-Length': Buffer.byteLength(body) }
              }, res => {
                let d = '';
                res.on('data', c => d += c);
                res.on('end', () => {
                  if (res.statusCode !== 200) { reject(new Error('API ' + res.statusCode + ': ' + d)); return; }
                  const p = JSON.parse(d);
                  resolve(p.content && p.content[0] && p.content[0].text ? p.content[0].text.trim() : null);
                });
              });
              req.on('error', reject);
              req.write(body);
              req.end();
            });
          }

          async function main() {
            console.log('Cleaner starting...');
            console.log('Source: ' + SOURCE_NAME);
            console.log('Input:  ' + INPUT);
            console.log('Output: ' + OUTPUT);

            if (!API_KEY) { console.error('No API key'); process.exit(1); }
            if (!fs.existsSync(INPUT)) { console.error('Input file not found: ' + INPUT); process.exit(1); }

            const posts = JSON.parse(fs.readFileSync(INPUT, 'utf8'));
            const total = posts.length;
            console.log('Posts: ' + total);

            let progress = fs.existsSync(PROGRESS) ? JSON.parse(fs.readFileSync(PROGRESS, 'utf8')) : {};
            const cleaned = posts.slice();
            let ok = 0, err = 0;

            for (let i = 0; i < posts.length; i++) {
              const post = posts[i];
              const key = post.post_name || String(i);

              if (progress[key]) {
                cleaned[i] = Object.assign({}, post, progress[key], { source: SOURCE_NAME });
                continue;
              }

              console.log('[' + (i+1) + '/' + total + '] ' + post.title.slice(0, 70));

              try {
                // Step 1: regex pre-clean the raw title and content
                const preTitle   = regexClean(post.title);
                const preContent = regexClean(post.clean_content || post.content || '');

                // Step 2: AI polish pass on already regex-cleaned text
                const titleSystem   = 'You are a copy editor. The text has already been regex-cleaned. Fix any remaining typos, capitalisation errors, or awkward phrasing in this title. Return ONLY the corrected title.';
                const contentSystem = 'You are a copy editor. The text has already been regex-cleaned for quote spacing. Fix any remaining typos, run-on words, or broken punctuation. Preserve the author voice exactly — do not rewrite or shorten. Separate paragraphs with a blank line. Return ONLY the cleaned text.';

                const t = await api(titleSystem, preTitle);
                await sleep(DELAY);
                const c = await api(contentSystem, preContent);
                await sleep(DELAY);

                const update = {
                  title: t || preTitle,
                  clean_content: c ? toHTML(c) : toHTML(preContent),
                  source: SOURCE_NAME,
                  ai_cleaned: true
                };

                cleaned[i] = Object.assign({}, post, update);
                progress[key] = update;
                fs.writeFileSync(PROGRESS, JSON.stringify(progress, null, 2));
                ok++;
              } catch(e) {
                console.log('Error: ' + e.message);
                // Even on API error, apply regex clean
                const preTitle   = regexClean(post.title);
                const preContent = regexClean(post.clean_content || post.content || '');
                cleaned[i] = Object.assign({}, post, { title: preTitle, clean_content: toHTML(preContent), source: SOURCE_NAME });
                err++;
                await sleep(2000);
              }
            }

            fs.writeFileSync(OUTPUT, JSON.stringify(cleaned, null, 2));
            console.log('Done: ' + ok + ' cleaned, ' + err + ' errors');
            console.log('Saved: ' + OUTPUT);
            if (err === 0 && fs.existsSync(PROGRESS)) fs.unlinkSync(PROGRESS);
          }

          main().catch(e => { console.error(e.message); process.exit(1); });
          EOF

      - name: Run cleaner
        run: node cleaner.mjs
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          SOURCE_NAME: ${{ github.event.inputs.source_name }}
          INPUT_FILE: ${{ github.event.inputs.input_file }}
          OUTPUT_FILE: ${{ github.event.inputs.output_file }}

      - name: Commit cleaned posts
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add ${{ github.event.inputs.output_file }}
          git commit -m "Cleaned ${{ github.event.inputs.source_name }} posts" || echo "Nothing to commit"
          git push